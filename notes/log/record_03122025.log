Compiled and ran a HIP program using the HIP_CPU framework.

Set-up a C++17 toolchain that integrates with the HIP_CPU headers and include directories.

HIP-CPU:
    
    CPU backend for HIP programming model. Without a real GPU, we can use this backend to "emulate" the parallelism that a GPU can give us without an actual GPU. We just use C++ parallelism and algorithmic techniques to parallelise as much aspossible a given workload on the CPU. 

    This still exposes the HIP programming model.


Exposure to the GPU programming model gave me insite into the way kernels are launched and how device-host interactions must be managed. 

*TAKEAWAYS*

    - HIP programming patterns such as passing the logical length of array into kernel; computing global thread indexes.
    
    - C/C++ array lesson. When an array is passed as a pointer to a function- i.e the array declaration is not in scope of where it is used, then sizeof(arr) will not work and the compiler will just see a pointer. sizeof(pointer) so on a 64 bit machine it will return 8.
    
    - When testing kernels it is a good idea to have a CPU reference implementation.
    
    - HIP_CPU uses very modern C++ parallelism and requires the newest paradigms of the language. Apple's default is not enough so I needed to use homebrew to install a more latest version of GCC. 
